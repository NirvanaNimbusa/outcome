<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Home on Boost.Outcome documentation</title>
    <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/</link>
    <description>Recent content in Home on Boost.Outcome documentation</description>
    <generator>Hugo -- gohugo.io</generator>
    
	<atom:link href="http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Incommensurate E types</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/interop/problem/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/interop/problem/</guid>
      <description>Back in the tutorial section on Default Actions, we studied a likely very common initial choice of E type: a strongly typed enum. We saw how by marking up strongly typed enums to tell the C++ standard library what they are, they gain implicit convertibility into std::error_code, and we then pointed out that you might as well now set E = std::error_code as that comes with the enormous advantage that you can use the boilerplate saving OUTCOME_TRY macro when the E type is always the same.</description>
    </item>
    
    <item>
      <title>User defined error types</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/default-actions/udt-err/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/default-actions/udt-err/</guid>
      <description>Let us imagine a some user defined value type (udt) and some user defined error type (err):
struct udt{int a{0};explicit udt(int _a): a(_a){}udt() = default;int operator*() const { return a; }};struct err{int a{0};explicit err(int _a): a(_a){}err() = default;}; View this code on GithubFirstly, note that both the udt and err types can be constructed from an int.</description>
    </item>
    
    <item>
      <title>ValueOrError Concept</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/interop/value-or-error/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/interop/value-or-error/</guid>
      <description>Something not really mentioned until now is how Outcome interoperates with the proposed std::expected&amp;lt;T, E&amp;gt;, whose design lands in between outcome::unchecked&amp;lt;T, E&amp;gt; and outcome::checked&amp;lt;T, E&amp;gt;, both of which are simplified aliases for outcome::result&amp;lt;T, E&amp;gt; hard coding the NoValuePolicy to a fixed policy.
Expected and Outcome are isomorphic to one another in design intent, but interoperation for code using Expected and Outcome ought to be seamless thanks to the proposed ValueOrError concept framework, a subset of which Outcome implements.</description>
    </item>
    
    <item>
      <title>-- What happens?</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/default-actions/happens1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/default-actions/happens1/</guid>
      <description>Let us run the code from the previous page:
ned@lyta:~/outcome/build_posix$ bin/outcome-snippets_udts Segmentation fault (core dumped) ned@lyta:~/outcome/build_posix$  Apparently no exception was thrown? Correct. Nor was a value printed, though this will randomly vary depending on your compiler, libraries, the wind blowing on the day &amp;hellip;
You will probably find this surprising. This is because the default action for a user-defined error type is undefined behaviour1.
Let us demonstrate this by recompiling the code to use the undefined behaviour sanitiser and see what happens instead:</description>
    </item>
    
    <item>
      <title>Anatomy of a policy</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/policies/anatomy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/policies/anatomy/</guid>
      <description>A NoValuePolicy is quite simple. This is a complete policy, only the top two thirds is needed if you never use the policy in an outcome.
struct blank_policy{//! Performs a narrow check of state, used in the assume_value() functions. template &amp;lt;class Impl&amp;gt; static constexpr void narrow_value_check(Impl &amp;amp;&amp;amp;self) noexcept;//! Performs a narrow check of state, used in the assume_error() functions. template &amp;lt;class Impl&amp;gt; static constexpr void narrow_error_check(Impl &amp;amp;&amp;amp;self) noexcept;//!</description>
    </item>
    
    <item>
      <title>Keeping state</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/hooks/keeping_state/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/hooks/keeping_state/</guid>
      <description>The first thing we are going to need is somewhere to store the stack backtrace. We could take the easier route and simply store it into an allocated block and keep the pointer as a custom payload in a result&amp;lt;T, std::pair&amp;lt;error_code, std::unique_ptr&amp;lt;stack_backtrace&amp;gt;&amp;gt;&amp;gt; (see previous section on Custom payloads). But let us assume that we care so deeply about bounded execution times that ever calling malloc is unacceptable.
We therefore are going to need some completely static and trivially typed storage perhaps kept per-thread to avoid the need to keep mutexes.</description>
    </item>
    
    <item>
      <title>Limitations</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/c-api/limitations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/c-api/limitations/</guid>
      <description>C++ has excellent two-way compatibility with the C ABI, but there are some limitations you must observe to write C++ code which C code can call without marshalling at the ABI boundary:
 A C++ function may not throw exceptions if it is safe to call from C, and so should always be marked noexcept. A C++ function should annotated with extern &amp;quot;C&amp;quot; to prevent its symbol being mangled, and thus give it the C rather than C++ ABI.</description>
    </item>
    
    <item>
      <title>The Filesystem TS</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/payload/copy_file/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/payload/copy_file/</guid>
      <description>Something which has long annoyed the purists in the C++ leadership is the problem of dual overloads in error_code capable standard library APIs.
Consider the copy_file() API from the Filesystem TS:
namespace filesystem{/*! Copies the file at path `from` to path `to`.\returns True if file was successfully copied.\throws On failure throws `filesystem_error(ec.message(), from, to, ec)` with`ec` being the error code reported by the operating system.*/bool copy_file(const path &amp;amp;from, const path &amp;amp;to);/*!</description>
    </item>
    
    <item>
      <title>The HTTP library</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/interop/httplib/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/interop/httplib/</guid>
      <description>Let us imagine a simple application: it fetches a HTTP page using a HTTP library, sends it through HTML tidy via the htmltidy library, and then writes it to disc using a filelib library. So three third party libraries, two using Outcome in incompatible ways, and the third being a C library just for kicks.
Let us imagine that the HTTP library has the following public interface:
// This is some standalone library implementing high level HTTPnamespace httplib{// These are the error code that this HTTP library can return enum class status_code{success = 0, // not the HTTP success code of 200// A subset of all HTTP status codes for brevity bad_request = 400,access_denied = 401,logon_failed = 402,forbidden = 403,not_found = 404,internal_error = 500};// This is the error type that this HTTP library can return struct failure{status_code status{status_code::success};std::string url{}; // The failing URL };// Localise a result implementation to this library template &amp;lt;class T&amp;gt; using result = BOOST_OUTCOME_V2_NAMESPACE::result&amp;lt;T, failure&amp;gt;;/* Performs a HTTP GET on the url, returning the body if successful,a failure with status_code if unsuccessful at the HTTP level, or aC++ exception throw if something catastrophic happened e.</description>
    </item>
    
    <item>
      <title>Two phase construction</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/constructors/two-phase-init/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/constructors/two-phase-init/</guid>
      <description>The first thing to do is to break your object&amp;rsquo;s construction into two phases:
 Place the object into a state where it can be legally destructed without doing any initialisation which could throw an exception (i.e. everything done in phase 1 is constexpr). This phase usually involves initialising member variables to various default values, most often using default member initialisers. Most standard C++ library objects and containers have constexpr constructors, and thus can be initialised during phase 1.</description>
    </item>
    
    <item>
      <title>The HTMLTidy library</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/interop/tidylib/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/interop/tidylib/</guid>
      <description>// There actually is a library for tidying HTML into XHTML called HTMLTidy// See http://www.html-tidy.org/// HTMLTidy is actually a great tool, I highly recommend it.// This isn&amp;#39;t the API for Tidy, but let&amp;#39;s assume it&amp;#39;s a C library returning// errno domained error codes. out must be freed with free() after use.extern &amp;#34;C&amp;#34; int tidy_html(char **out, size_t *outlen, const char *in, size_t inlen); View this code on GithubA C API may not initially appear to be a T|E based API, but if failure returns some domained error code and causes no other effects, and success returns some value, then it is effectively a &amp;ldquo;split&amp;rdquo; T|E API.</description>
    </item>
    
    <item>
      <title>A file handle</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/constructors/file_handle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/constructors/file_handle/</guid>
      <description>Borrowing from afio::file_handle which uses this design pattern, here is a simplified file_handle implementation:
class file_handle{int _fd{-1}; // file descriptor struct stat _stat{0}; // stat of the fd at open// Phase 1 private constexpr constructor constexpr file_handle() {}public:using path_type = filesystem::path;//! The behaviour of the handle: does it read, read and write, or atomic append? enum class mode : unsigned char // bit 0 set means writable {unchanged = 0,none = 2, //!</description>
    </item>
    
    <item>
      <title>ADL bridging</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/hooks/adl_bridging/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/hooks/adl_bridging/</guid>
      <description>In a previous section, we used the failure_info type to create the ADL bridge into the namespace where the ADL discovered throw_as_system_error_with_payload() function was to be found.
Here we do the same, but more directly by creating a thin clone of std::error_code into the local namespace. This ensures that this namespace will be searched by the compiler when discovering the event hooks.
namespace error_code_extended{// Use the error_code type as the ADL bridge for the hooks by creating a type here // It can be any type that your localised result uses, including the value type but // by localising the error code type here you prevent nasty surprises later when the // value type you use doesn&amp;#39;t trigger the ADL bridge.</description>
    </item>
    
    <item>
      <title>Casting workaround</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/policies/cast/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/policies/cast/</guid>
      <description>The templated Impl type on each policy function is decltype(*this) of the part of Outcome&amp;rsquo;s internal implementation which calls the policy. It therefore may be quite removed from the actual outcome type in play, and thus the .exception() member function and others belonging to outcome only will not be immediately visible.
Hence a very common thing you&amp;rsquo;ll need to do is static cast to a more derived form before use like this:</description>
    </item>
    
    <item>
      <title>Error code enums</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/default-actions/enums/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/default-actions/enums/</guid>
      <description>Let&amp;rsquo;s replace err with something likely in many people&amp;rsquo;s code, a strongly typed enum:
struct udt{int a{0};explicit udt(int _a): a(_a){}udt() = default;int operator*() const { return a; }};enum class err{success, // REMEMBER it is best practice to always put &amp;#34;success&amp;#34; failure1, // with value 0 as your first item in any error code failure2 // enum, even if you never use it.</description>
    </item>
    
    <item>
      <title>Example C&#43;&#43; function</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/c-api/example/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/c-api/example/</guid>
      <description>Let us start with a simple C++ function which we wish to make available to C code:
// Fill the supplied buffer with the integer v converted to a string, returning// length of string minus null terminatorextern &amp;#34;C&amp;#34; outcome::result&amp;lt;size_t&amp;gt; to_string(char *buffer, size_t bufferlen, int v) noexcept{try{// Could throw an exception! std::string temp(std::to_string(v));// Will this string exceed the supplied buffer? if(temp.size() + 1 &amp;gt; bufferlen)return std::errc::no_buffer_space;// Copy the string into the supplied buffer, and return length of string memcpy(buffer, temp.</description>
    </item>
    
    <item>
      <title>Inspecting result&lt;T, EC&gt;</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/result/inspecting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/result/inspecting/</guid>
      <description>Suppose we will be writing function print_half that takes an integral number (however big) represented as an std::string and outputs a number which is twice smaller:
outcome::result&amp;lt;void&amp;gt; print_half(const std::string&amp;amp; text); View this code on GithubType result&amp;lt;void&amp;gt; means that there is no value to be retuned upon success, but that the operation might still fail, and we may be interested in inspecting the cause of the failure. Class template result&amp;lt;&amp;gt; is declared with attribute [[nodiscard]], which means compiler will warn you if you forget to inspect the returned object (in C++ 17 or later).</description>
    </item>
    
    <item>
      <title>The File I/O library</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/interop/filelib/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/interop/filelib/</guid>
      <description>The File I/O library we shall be using is very similar to the one we saw earlier in this tutorial:
// You may remember this from the tutorial section on Custom Payloadsnamespace filelib{// Error code + paths related to a failure. Also causes ADL discovery to check this namespace. struct failure_info{std::error_code ec;path path1{}, path2{};};// Tell Outcome that failure_info is to be treated as a std::error_code inline const std::error_code &amp;amp;make_error_code(const failure_info &amp;amp;fi) { return fi.</description>
    </item>
    
    <item>
      <title>Upgrading the Filesystem TS</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/payload/copy_file2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/payload/copy_file2/</guid>
      <description>An Outcome based solution to the dual overload problem is straightforward:
namespace filesystem2{// Error code + paths related to a failure. Also causes ADL discovery to check this namespace. struct failure_info{std::error_code ec;path path1, path2;};// Tell Outcome that failure_info is to be treated as a std::error_code inline const std::error_code &amp;amp;make_error_code(const failure_info &amp;amp;fi) { return fi.ec; }// Localise an outcome implementation specific to this namespace.</description>
    </item>
    
    <item>
      <title>-- What happens?</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/default-actions/happens2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/default-actions/happens2/</guid>
      <description>Let us run the code from the previous page:
ned@lyta:~/outcome/build_posix$ bin/outcome-snippets_error_code_enums1 Segmentation fault (core dumped) ned@lyta:~/outcome/build_posix$  Also undefined behaviour. This is because Outcome doesn&amp;rsquo;t know what to do with a strongly typed enum any more than some user defined struct.
Let us register our error code enum with the C++ standard library. This causes Outcome to treat it quite differently.
struct udt{int a{0};explicit udt(int _a): a(_a){}udt() = default;int operator*() const { return a; }};enum class err{success,failure1,failure2};// Tell the standard library that enum err is an error code enum// by specialising the is_error_code_enum trait.</description>
    </item>
    
    <item>
      <title>The Application</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/interop/app/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/interop/app/</guid>
      <description>The application is of course also based on Outcome, and like the HTTP library is also of mixed-failure design in that failure can be returned via error code, type erased exception_ptr or indeed a C++ exception throw.
// This is the namespace of the application which is connecting together the httplib,// filelib and tidylib libraries into a solution.namespace app{// Create an ADL bridge so copy/move hooks will be searched for in this namespace struct error_code : public std::error_code{// passthrough using std::error_code::error_code;error_code() = default;error_code(std::error_code ec): std::error_code(ec){}};// Localise an outcome implementation for this namespace template &amp;lt;class T&amp;gt; using outcome = BOOST_OUTCOME_V2_NAMESPACE::outcome&amp;lt;T, error_code /*, std::exception_ptr */&amp;gt;;using BOOST_OUTCOME_V2_NAMESPACE::success;} View this code on GithubHere we localise a passthrough error_code solely for the purpose of ADL bridging, otherwise the localised outcome configured is the default one which comes with Outcome.</description>
    </item>
    
    <item>
      <title>-- Now what happens?</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/default-actions/happens3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/default-actions/happens3/</guid>
      <description>Let us run the code from the previous page:
ned@lyta:~/outcome/build_posix$ bin/outcome-snippets_error_code_enums2 Exception thrown was failure1 ned@lyta:~/outcome/build_posix$  Ah so now we are throwing a C++ exception on no-value observation! This is because we registered our error code enum with the C++ standard library and in so doing, we also told the standard library how our error code interacts with std::error_code and thus std::system_error.
Outcome&amp;rsquo;s default action when no-value observing a result or outcome with a EC type where some ADL discovered free function make_error_code(EC) returning a std::error_code exists1, is to throw a std::system_error(make_error_code(.</description>
    </item>
    
    <item>
      <title>Auto-throwing filesystem_error</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/payload/copy_file3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/payload/copy_file3/</guid>
      <description>Something not mentioned at all until now (and properly described in the next section, Default actions) is that Outcome can be programmed take various actions when the user tries to observe .value() when there is no value, and so on for the other possible state observations.
Seeing as we are replacing the throwing overload of copy_file() in the Filesystem TS with a result returning edition instead, it would make sense if an attempt to observe the value of an unsuccessful fs_result threw the exact same filesystem_error as the Filesystem TS does.</description>
    </item>
    
    <item>
      <title>Built-in policies</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/policies/builtin/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/policies/builtin/</guid>
      <description>These are the precanned policies built into Outcome:
 all_narrow Wide checks call their narrow check cousins only. Narrow checks call a function called _ub() which:
 Is marked with any compiler-specific markup to say it will never return, which should cause the compiler&amp;rsquo;s optimiser to generate perfectly minimum code. Calls __builtin_unreachable() on compilers which support that intrinsic to further encourage perfectly minimum code (and to trigger the undefined behaviour sanitiser if execution ever reaches such a code path).</description>
    </item>
    
    <item>
      <title>Calling it from C</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/c-api/example2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/c-api/example2/</guid>
      <description>Now let us call our result returning C++ function from C:
#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt; // for strerror// This header in Outcome is pure C, it provides a suite of C helper macros#include &amp;#34;../../../include/outcome/result.h&amp;#34;// Declare our C++ function&amp;#39;s returning result type. Only needs to be done once.CXX_DECLARE_RESULT_EC(size_t, size_t);// Tell C about our C++ functionextern CXX_RESULT_EC(size_t) to_string(char *buffer, size_t bufferlen, int v);void print(int v){char buffer[4];CXX_RESULT_EC(size_t) res;res = to_string(buffer, sizeof(buffer), v);if(CXX_RESULT_HAS_VALUE(res)){printf(&amp;#34;to_string(%d) fills buffer with &amp;#39;%s&amp;#39; of %zu characters\n&amp;#34;, v, buffer, res.</description>
    </item>
    
    <item>
      <title>Hook result</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/hooks/hook_result/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/hooks/hook_result/</guid>
      <description>We now tell Outcome that for every instance of our localised result&amp;lt;T&amp;gt;, that on failure construction only, we want custom code to be run which increments the current slot in TLS storage and writes the current stack backtrace into it.
namespace error_code_extended{// Specialise the result construction hook for our localised result // We hook any non-copy, non-move, non-inplace construction, capturing a stack backtrace // if the result is errored.</description>
    </item>
    
    <item>
      <title>Inspecting outcome&lt;T, EC, EP&gt;</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/outcome/inspecting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/outcome/inspecting/</guid>
      <description>Continuing with the previous example, in Layer3 we obtain an outcome&amp;lt;double&amp;gt; which may store a double or an std::error_code or an std::exception_ptr. Layer3 uses exceptions to indicate failure, so we want to turn a failed result into an exception: if we are storing an std::exception_ptr just rethrow it. If we are storing an std::error_code throw it as std::system_error, which is designed to store std::error_codes:
namespace Layer3{auto run() -&amp;gt; double // may throw {if (outcome::outcome&amp;lt;double&amp;gt; o = Layer2NX::fun())return o.</description>
    </item>
    
    <item>
      <title>Mapping the HTTP library into the Application 1/2</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/interop/app-map-httplib1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/interop/app-map-httplib1/</guid>
      <description>Firstly we are going to need to wrap up httplib::failure into a custom STL exception type before we can type erase it into an exception_ptr instance. Please note that this code is defined in the app namespace:
namespace app{// Specialise an exception type for httplib errors struct httplib_error : std::runtime_error{// passthrough using std::runtime_error::runtime_error;httplib_error(httplib::failure _failure, std::string msg): std::runtime_error(std::move(msg)), failure(std::move(_failure)){}// the original failure httplib::failure failure;};// Type erase httplib::result&amp;lt;U&amp;gt; into a httplib_error exception ptr template &amp;lt;class U&amp;gt; inline std::exception_ptr make_httplib_exception(const httplib::result&amp;lt;U&amp;gt; &amp;amp;src){std::string str(&amp;#34;httplib failed with error &amp;#34;);switch(src.</description>
    </item>
    
    <item>
      <title>Phase 2 construction</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/constructors/static-constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/constructors/static-constructor/</guid>
      <description>Its phase 2 constructor:
// Phase 2 static member constructor function, which cannot throwinline outcome::result&amp;lt;file_handle&amp;gt; file_handle::file(file_handle::path_type path, file_handle::mode mode) noexcept{// Perform phase 1 of object construction file_handle ret;// Perform phase 2 of object construction int flags = 0;switch(mode){case mode::attr_read:case mode::read:flags = O_RDONLY;break;case mode::attr_write:case mode::write:flags = O_RDWR;break;case mode::append:flags = O_APPEND;break;default:return std::errc::invalid_argument;}ret.</description>
    </item>
    
    <item>
      <title>TRY operations</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/result/try/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/result/try/</guid>
      <description>In the implementation of function print_half we have seen the usage of the macro OUTCOME_TRY:
OUTCOME_TRY (i, BigInt::fromString(text));  This control statement is raughly equivalent to:
auto&amp;amp;&amp;amp; __result = BigInt::fromString(text); if (!__result) return __result.as_failure(); auto&amp;amp;&amp;amp; i = __result.value();  Where __result is a unique name.
Additionally, in GCC and Clang which provide an extension to C++ known as statement expressions it is possible to use an alternative macro: OUTCOME_TRYX, which is an expression.</description>
    </item>
    
    <item>
      <title>error_code</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/default-actions/error-codes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/default-actions/error-codes/</guid>
      <description>Now that we have told the C++ standard library about our custom error code enum err, we actually no longer need to specify EC = err, we can just leave it default to std::error_code:
result&amp;lt;udt /*, std::error_code */&amp;gt; res(err::failure1);// What happens here? What exception type is thrown? try{std::cout &amp;lt;&amp;lt; *res.value() &amp;lt;&amp;lt; std::endl;}catch(const std::exception &amp;amp;e){// Prints &amp;#34;Exception thrown was failure1&amp;#34;, exactly the same as before std::cerr &amp;lt;&amp;lt; &amp;#34;Exception thrown was &amp;#34; &amp;lt;&amp;lt; e.</description>
    </item>
    
    <item>
      <title>Mapping the HTTP library into the Application 2/2</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/interop/app-map-httplib2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/interop/app-map-httplib2/</guid>
      <description>If you remember the tutorial section on the ValueOrError Concept, this is an example of how to implement a custom ValueOrError Concept converter in Outcome:
// Inject custom ValueOrError conversionBOOST_OUTCOME_V2_NAMESPACE_BEGINnamespace convert{// Provide custom ValueOrError conversion from httplib::result&amp;lt;U&amp;gt; into any app::outcome&amp;lt;T&amp;gt; template &amp;lt;class T, class U&amp;gt; struct value_or_error&amp;lt;app::outcome&amp;lt;T&amp;gt;, httplib::result&amp;lt;U&amp;gt;&amp;gt;{// False to indicate that this converter wants `result`/`outcome` to NOT reject all other `result` static constexpr bool enable_result_inputs = true;// False to indicate that this converter wants `outcome` to NOT reject all other `outcome` static constexpr bool enable_outcome_inputs = true;template &amp;lt;class X, // typename = std::enable_if_t&amp;lt;std::is_same&amp;lt;httplib::result&amp;lt;U&amp;gt;, std::decay_t&amp;lt;X&amp;gt;&amp;gt;::value // &amp;amp;&amp;amp; std::is_constructible&amp;lt;T, U&amp;gt;::value&amp;gt;&amp;gt; // constexpr app::outcome&amp;lt;T&amp;gt;operator()(X &amp;amp;&amp;amp;src){// Forward any successful value, else synthesise an exception ptr return src.</description>
    </item>
    
    <item>
      <title>Custom exception ptr</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/hooks/poke_exception/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/hooks/poke_exception/</guid>
      <description>If you merely want result to capture stack backtraces without calling a memory allocator and retaining any triviality of copy which is important for optimisation, you already have everything you need.
But let&amp;rsquo;s keep going by intercepting any construction of our localised outcome from our localised result, retrieving any stored backtrace and using it to synthesise an exception ptr with a message text including the backtrace. Firstly let us look at the function which synthesises the exception ptr:</description>
    </item>
    
    <item>
      <title>Mapping the File I/O library into the Application</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/interop/app-map-filelib/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/interop/app-map-filelib/</guid>
      <description>To handle the File I/O library, once again we turn to custom ValueOrError converters:
// Inject custom ValueOrError conversionBOOST_OUTCOME_V2_NAMESPACE_BEGINnamespace convert{// Provide custom ValueOrError conversion from filelib::result&amp;lt;U&amp;gt; into any app::outcome&amp;lt;T&amp;gt; template &amp;lt;class T, class U&amp;gt; struct value_or_error&amp;lt;app::outcome&amp;lt;T&amp;gt;, filelib::result&amp;lt;U&amp;gt;&amp;gt;{// True to indicate that this converter wants `result`/`outcome` to NOT reject all other `result` static constexpr bool enable_result_inputs = true;// False to indicate that this converter wants `outcome` to NOT reject all other `outcome` static constexpr bool enable_outcome_inputs = true;template &amp;lt;class X, // typename = std::enable_if_t&amp;lt;std::is_same&amp;lt;filelib::result&amp;lt;U&amp;gt;, std::decay_t&amp;lt;X&amp;gt;&amp;gt;::value // &amp;amp;&amp;amp; std::is_constructible&amp;lt;T, U&amp;gt;::value&amp;gt;&amp;gt; // constexpr app::outcome&amp;lt;T&amp;gt;operator()(X &amp;amp;&amp;amp;src){// Forward any successful value if(src.</description>
    </item>
    
    <item>
      <title>Phase 3</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/constructors/metaprogrammg1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/constructors/metaprogrammg1/</guid>
      <description>We have built our first two phases of construction for file_handle, and for some users they might be happy writing:
outcome::result&amp;lt;file_handle&amp;gt; fh1 = file_handle::file(&amp;#34;hello&amp;#34; /*, file_handle::mode::read */);if(!fh1){std::cerr &amp;lt;&amp;lt; &amp;#34;Opening file &amp;#39;hello&amp;#39; failed with &amp;#34; &amp;lt;&amp;lt; fh1.error().message() &amp;lt;&amp;lt; std::endl;} View this code on Github&amp;hellip; and be done with it.
But wouldn&amp;rsquo;t it be nicer if we could instead write:
outcome::result&amp;lt;file_handle&amp;gt; fh2 = construct&amp;lt;file_handle&amp;gt;{&amp;#34;hello&amp;#34; /*, file_handle::mode::read */}();if(!</description>
    </item>
    
    <item>
      <title>Variations</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/c-api/variations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/c-api/variations/</guid>
      <description>You can of course choose your own E type so long as it has standard layout and is trivially copyable. You would declare that with CXX_DECLARE_RESULT(t_ident, t_decl, e_ident, e_decl), refer to it with CXX_RESULT(t_ident, e_ident) and need to do your own decoding of errors from your E type. By using the _EC postfixed macros, you are in fact using E =
struct cxx_error_code { int code; void *category; };  &amp;hellip; which is declared for you by result.</description>
    </item>
    
    <item>
      <title>exception_ptr</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/default-actions/exception-ptr/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/default-actions/exception-ptr/</guid>
      <description>Another default action exists for result&amp;lt;T, EC&amp;gt; where trait::has_exception_ptr&amp;lt;EC&amp;gt; is true, and for outcome&amp;lt;T, EC, EP&amp;gt; where either or both trait::has_exception_ptr&amp;lt;EC&amp;gt; and trait::has_exception_ptr&amp;lt;EP&amp;gt; is true.
This default action simply rethrows the exception pointer via std::rethrow_exception(make_exception_ptr(.error())) for result and std::rethrow_exception(make_exception_ptr(.error())) and/or std::rethrow_exception(make_exception_ptr(.exception())) for outcome, if trait::has_exception_ptr&amp;lt;EC&amp;gt; and/or trait::has_exception_ptr&amp;lt;EP&amp;gt; is true.
struct udt{int a{0};explicit udt(int _a): a(_a){}udt() = default;int operator*() const { return a; }};result&amp;lt;udt, std::exception_ptr&amp;gt; res(std::make_exception_ptr(std::runtime_error(&amp;#34;hello&amp;#34;)));// What happens here?</description>
    </item>
    
    <item>
      <title>Mapping the HTMLTidy library into the Application</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/interop/app-map-tidylib/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/interop/app-map-tidylib/</guid>
      <description>Once again, we create a custom STL exception type to represent failure from the HTMLTidy library. We also create an app namespace wrapper for the C tidy_html() function which is more C++ friendly.
namespace app{// Specialise an exception type for tidylib errors struct tidylib_error : std::system_error{// passthrough using std::system_error::system_error;tidylib_error() = default;explicit tidylib_error(int c): std::system_error(c, std::generic_category()){}};// Create a C++ invoking wrapper for the tidylib C API, modifying data with the returned data, // returing a unique_ptr to release storage on scope exit.</description>
    </item>
    
    <item>
      <title>Hook outcome</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/hooks/hook_outcome/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/hooks/hook_outcome/</guid>
      <description>The final step is to add ADL discovered event hooks for the very specific case of when our localised outcome is copy or move constructed from our localised result. There isn&amp;rsquo;t really much to say about these, just be careful to mark them noexcept or not based on whether the types T, EC or EP could throw during copy or move construction. As poke_exception() creates a std::string and appends to it, it could indeed throw an exception and thus with the noexcept hooks below, the process would be terminated.</description>
    </item>
    
    <item>
      <title>In use</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/interop/app-go/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/interop/app-go/</guid>
      <description>This is how you might now write application code using these three libraries:
namespace app{outcome&amp;lt;void&amp;gt; go() // NOT noexcept, this can throw STL exceptions e.g. bad_alloc {// Note that explicit construction is required when converting between differing types // of outcome and result. This makes it explicit what you intend to do as conversion // may be a lot more expensive than moves.// Try to GET this URL.</description>
    </item>
    
    <item>
      <title>construct&lt;T&gt;</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/constructors/metaprogrammg2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/constructors/metaprogrammg2/</guid>
      <description>First, we need a base definition for construct&amp;lt;T&amp;gt;:
template &amp;lt;class T&amp;gt; struct construct{outcome::result&amp;lt;T&amp;gt; operator()() const noexcept{ // static_assert(!std::is_same&amp;lt;T, T&amp;gt;::value, &amp;#34;construct&amp;lt;T&amp;gt;() was not specialised for the type T supplied&amp;#34;);}}; View this code on GithubThis fails a static assert if the type is ever instantiated unspecialised.
We then specialise for construct&amp;lt;file_handle&amp;gt;:
template &amp;lt;&amp;gt; struct construct&amp;lt;file_handle&amp;gt;{file_handle::path_type _path;file_handle::mode _mode{file_handle::mode::read};// Any other args, default initialised if necessary, follow here .</description>
    </item>
    
    <item>
      <title>void</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/default-actions/void/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/default-actions/void/</guid>
      <description>What about result&amp;lt;udt, void&amp;gt;? This is absolutely legal, it means that no error state is returned when there was an error. This can help with clarifying in code the use of std::optional&amp;lt;udt&amp;gt; as Optional more logically means value-or-nothing, not necessarily value-or-error.
In contrast, result&amp;lt;udt, void&amp;gt; unambiguously does mean success-or-failure, just with an unspecified cause of failure.
Outcome&amp;rsquo;s default action for EC = void is to call std::terminate:
struct udt{int a{0};explicit udt(int _a): a(_a){}udt() = default;int operator*() const { return a; }};result&amp;lt;udt, void&amp;gt; res(in_place_type&amp;lt;void&amp;gt;);// What happens here?</description>
    </item>
    
    <item>
      <title>Conclusion</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/interop/conclusion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/interop/conclusion/</guid>
      <description>This worked example was in fact excessively complex: a quicker route to achieving the same thing would be to add explicit converting constructors to app::error_code for each of the third party library E types. One then could have saved oneself with having to bother injecting custom converters into the OUTCOME_V2_NAMESPACE::convert namespace.
However there are occasions when you don&amp;rsquo;t have control over the implementation of the destination E type e.g. in callbacks.</description>
    </item>
    
    <item>
      <title>Alternatives</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/constructors/metaprogrammg3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/constructors/metaprogrammg3/</guid>
      <description>No doubt many will dislike the two-stage invocation pattern i.e.
construct&amp;lt;file_handle&amp;gt;{&amp;#34;hello&amp;#34;}();  So let us examine the most obvious alternative: a templated free function construct&amp;lt;T&amp;gt;.
Due to the inability to partially specialise templated functions in C++, you need to use tagged overloading e.g.
template&amp;lt;class... Args&amp;gt; inline outcome::result&amp;lt;file_handle&amp;gt; construct(std::in_place_type_t&amp;lt;file_handle&amp;gt;, Args&amp;amp;&amp;amp; ... args) { return file_handle::file(std::forward&amp;lt;Args&amp;gt;(args)...); } ... // Now you must always write this: construct(std::in_place_type&amp;lt;file_handle&amp;gt;, &amp;#34;hello&amp;#34;);  Tagged overloading is fine for smaller projects, but for larger code bases:</description>
    </item>
    
    <item>
      <title>unchecked&lt;T, E&gt; and checked&lt;T, E&gt;</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/default-actions/unchecked/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/default-actions/unchecked/</guid>
      <description>We have now covered all of the default actions in Outcome whereby result&amp;lt;T, EC&amp;gt; and outcome&amp;lt;T, EC, EP|P&amp;gt; implement various default actions upon no-value observation according to traits defined upon the EC and EP|P chosen.
If you don&amp;rsquo;t want all this clever automatic detection of traits, and just want a plain, always-undefined-behaviour-on-no-value-observation success-or-failure type, we provide a simplified template alias to result&amp;lt;T, E&amp;gt; called unchecked&amp;lt;T, E&amp;gt;. It literally does no run time checking whatsoever, no-value observation is always undefined behaviour.</description>
    </item>
    
    <item>
      <title>Custom error codes</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/error_code/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/tutorial/error_code/</guid>
      <description>This section illustrates how you can hook into the std::error_code system from the Standard Library in order to work with your own set of error codes. As is usually the case in C++, doing this is straightforward but requires typing boilerplate to tell the C++ STL about your custom error type. This is not part of Outcome library, but we still provide this short guide here, because how to do this is not well documented [1].</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/_header/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/_header/</guid>
      <description>Outcome 2.0 library documentation</description>
    </item>
    
    <item>
      <title>Acknowledgements</title>
      <link>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/credits/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.boost.org/doc/libs/1_65_1/libs/outcome/doc/html/credits/</guid>
      <description>github contributors .ghContributors{display:flex;flex-flow: wrap;align-content: flex-start}.ghContributors  div{width: 50% ;display: inline-flex;margin-bottom: 5px;}.ghContributors  div label{padding-left: 4px ;}.ghContributors  div span{font-size: x-small;padding-left: 4px ;}@ned14652 commits@akrzemi19 commits@jenkins-nedprod1 commits This pretty, modern C++ documentation  Hugo - static website generator of this documentation. hugo-theme-docdock - the Hugo theme used by this documentation.</description>
    </item>
    
  </channel>
</rss>