/* Example of Outcome
(C) 2017-2019 Niall Douglas <http://www.nedproductions.biz/> (149 commits)


Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#include <boost/outcome.hpp>
#include <boost/asio/associated_executor.hpp>
#include <boost/asio/associated_allocator.hpp>
#include <boost/asio/async_result.hpp>
#include <boost/asio/detail/handler_alloc_helpers.hpp>
#include <boost/asio/detail/handler_invoke_helpers.hpp>
#include <boost/system/error_code.hpp>

#include <vector>

namespace asio = boost::asio;
namespace outcome = boost::outcome_v2;

using byte = char;

int old()
{
  //! [old-use-case]
  // Dynamically allocate a buffer to read into. This must be move-only
  // so it can be attached to the completion handler, hence the unique_ptr.
  auto buffer = std::make_unique<std::unique_ptr<std::vector<byte>>>(1024);  

  // Begin an asynchronous socket read, upon completion invoke
  // the lambda function specified
  asio::async_read(socket,
    asio::buffer(buffer->data(), buffer->size()),
    
    // Retain lifetime of the i/o buffer until completion
    [buffer](const error_code &ec, size_t bytes) {
      // Handle the buffer read
      if(ec)
      {
        std::cerr << "Buffer read failed with " << ec << std::endl;
        return;
      }
      std::cout << "Read " << bytes << " bytes into buffer" << std::endl;
      
      // buffer will be dynamically freed now
  });
  //! [old-use-case]
}

int new_()
{
  //! [new-use-case]
  // As coroutines suspend the calling thread whilst an asynchronous
  // operation executes, we can use stack allocation instead of dynamic
  // allocation
  char buffer[1024];
  
  // Get an ASIO completion token for the current coroutine (requires
  // Coroutines TS)
  auto token = co_await asio::experimental::this_coro::token();

  // Asynchronously read data, suspending this coroutine until completion,
  // returning the bytes of the data read into the result.
  try
  {
    std::size_t read = co_await asio::async_read(socket, buffer, token);
    std::cout << "Read " << bytes << " bytes into buffer" << std::endl;
  }
  catch(const std::system_error &e)
  {
    std::cerr << "Buffer read failed with " << e << std::endl;
  }
  //! [new-use-case]
}

int outcome()
{
  //! [outcome-use-case]
  // Asynchronously read data, suspending this coroutine until completion,
  // returning the bytes of the data read into the result, or any failure.
  outcome::result<std::size_t> read = //
    co_await asio::async_read(socket, buffers, as_result(token));
  
  // Usage is exactly like ordinary Outcome. Note the lack of exception throw!
  if(read.has_error())
  {
    std::cerr << "Buffer read failed with " << read.error() << std::endl;
    return;
  }
  std::cout << "Read " << bytes.value() << " bytes into buffer" << std::endl;
  //! [outcome-use-case]
}

int main(void)
{
  return 0;
}
