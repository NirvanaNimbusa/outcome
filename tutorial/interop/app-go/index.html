<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>In use - Boost.Outcome documentation</title>
<link rel="stylesheet" href="/boost-outcome/css/boost.css" type="text/css">
<meta name="generator" content="Hugo with Boostdoc theme">
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>

<link rel="icon" href="/boost-outcome/images/favicon.ico" type="image/ico"/>
<body><div id="boost-common-heading-doc" style="background: #574D74 url(/boost-outcome/images/header-bg.png) repeat-x top left;">
  <div class="heading-inner" style="background: url(/boost-outcome/images/header-fg.png) no-repeat top left;">
  <div class="heading-placard"></div>

  <h1 class="heading-title">
    <a href="/">
      <img src="/boost-outcome/images/space.png" alt="Boost C++ Libraries" class="heading-logo" />
      <span class="heading-boost">Boost</span>
      <span class="heading-cpplibraries">C++ Libraries</span>
    </a>
  </h1>

  <p class="heading-quote">
    <q>...one of the most highly
    regarded and expertly designed C++ library projects in the
    world.</q> <span class="heading-attribution">&mdash; <a href=
    "http://www.gotw.ca/" class="external">Herb Sutter</a> and <a href=
    "http://en.wikipedia.org/wiki/Andrei_Alexandrescu" class="external">Andrei
    Alexandrescu</a>, <a href=
    "http://safari.awprofessional.com/?XmlId=0321113586" class="external">C++
    Coding Standards</a></span></p>
  </div>
</div>
<div id="boost-common-heading-doc-spacer"></div>
<div id="content">
    <p>This is how you might now write application code using these three libraries:</p>

<div class="code-snippet"><div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++">
<span class="k">namespace</span> <span class="n">app</span>
<span class="p">{</span>
  <span class="n">outcome</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">go</span><span class="p">()</span>  <span class="c1">// NOT noexcept, this can throw STL exceptions e.g. bad_alloc
</span><span class="c1"></span>  <span class="p">{</span>
    <span class="c1">// Note that explicit construction is required when converting between differing types
</span><span class="c1"></span>    <span class="c1">// of outcome and result. This makes it explicit what you intend to do as conversion
</span><span class="c1"></span>    <span class="c1">// may be a lot more expensive than moves.
</span><span class="c1"></span>
    <span class="c1">// Try to GET this URL. If an unsuccessful HTTP status is returned, serialise a string
</span><span class="c1"></span>    <span class="c1">// containing a description of the HTTP status code and the URL which failed, storing
</span><span class="c1"></span>    <span class="c1">// that into a httplib_error exception type which is stored as an exception ptr. The
</span><span class="c1"></span>    <span class="c1">// TRY operation below will return that exception ptr to be rethrown in the caller.
</span><span class="c1"></span>    <span class="c1">// Otherwise the fetched data is returned in a std::string data.
</span><span class="c1"></span>    <span class="n">BOOST_OUTCOME_TRY</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">outcome</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="n">httplib</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="s">&#34;http://www.nedproductions.biz/&#34;</span><span class="p">))));</span>
    <span class="n">string_view</span> <span class="nf">data_view</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

    <span class="c1">// HTML tidy the fetched data. If the C library fails due to an error corresponding to
</span><span class="c1"></span>    <span class="c1">// a standard library exception type, throw that. Otherwise, synthesise an exception
</span><span class="c1"></span>    <span class="c1">// ptr of type tidylib_error which stores the error code returned in an error code with
</span><span class="c1"></span>    <span class="c1">// generic category (i.e. errno domain).
</span><span class="c1"></span>    <span class="c1">// TRY operation below will return that exception ptr to be rethrown in the caller.
</span><span class="c1"></span>    <span class="c1">// Otherwise the tidied data is returned into holdmem, with the string view updated to
</span><span class="c1"></span>    <span class="c1">// point at the tidied data.
</span><span class="c1"></span>    <span class="n">BOOST_OUTCOME_TRY</span><span class="p">(</span><span class="n">holdmem</span><span class="p">,</span> <span class="p">(</span><span class="n">tidy_html</span><span class="p">(</span><span class="n">data_view</span><span class="p">)));</span>

    <span class="c1">// Write the tidied data to some file. If the write fails, synthesise a filesystem_error
</span><span class="c1"></span>    <span class="c1">// exception ptr exactly as if one called filelib::write_file(data_view).value().
</span><span class="c1"></span>    <span class="n">BOOST_OUTCOME_TRY</span><span class="p">(</span><span class="n">written</span><span class="p">,</span> <span class="p">(</span><span class="n">outcome</span><span class="o">&lt;</span><span class="n">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">filelib</span><span class="o">::</span><span class="n">write_file</span><span class="p">(</span><span class="n">data_view</span><span class="p">))));</span>
    <span class="k">return</span> <span class="nf">success</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><a href="https://github.com/ned14/boost-outcome/tree/master/doc/src/snippets/finale.cpp#L350" class="code-snippet-url" target="_blank">View this code on Github</a></div>


<p>Many will wish that the explicit converting wrappers around third party
library APIs were not there. Note that in C++ 17 you should be able to
dispense with the angle bracketed type as the compiler can now deduce that.
But one must still wrap all third party API invocations with <code>outcome()</code>
i.e. explicit construction to namespace-localised <code>outcome</code>.
This is a deliberate design decision: in Outcome, all <em>converting</em>
construction is always explicit, except when the source is <code>success</code> or
<code>failure</code> type sugar. And down the line when others come to maintain
this code, we think it will be very useful to be explicit on this because
user defined code that we customised earlier is being executed.</p>

<p>Note also that we are able to use <code>TRY</code> throughout this function,
and most especially note that we never, at any stage, needed to modify
the source code of <code>httplib</code>, <code>tidylib</code> nor <code>filelib</code>, or inject
custom things into their namespaces. This entire worked example was
achieved solely by <code>app</code> based customisation points and via <code>convert</code>.</p>


        </div></body>
</html>
