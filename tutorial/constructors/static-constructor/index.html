<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Phase 2 construction - Boost.Outcome documentation</title>
<link rel="stylesheet" href="/boost-outcome/css/boost.css" type="text/css">
<meta name="generator" content="Hugo with Boostdoc theme">
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>

<link rel="icon" href="/boost-outcome/images/favicon.ico" type="image/ico"/>
<body><div id="content">
    <p>Its phase 2 constructor:</p>

<div class="code-snippet"><div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++">
<span class="c1">// Phase 2 static member constructor function, which cannot throw
</span><span class="c1"></span><span class="kr">inline</span> <span class="n">outcome</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="n">file_handle</span><span class="o">&gt;</span> <span class="n">file_handle</span><span class="o">::</span><span class="n">file</span><span class="p">(</span><span class="n">file_handle</span><span class="o">::</span><span class="n">path_type</span> <span class="n">path</span><span class="p">,</span> <span class="n">file_handle</span><span class="o">::</span><span class="n">mode</span> <span class="n">mode</span><span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
  <span class="c1">// Perform phase 1 of object construction
</span><span class="c1"></span>  <span class="n">file_handle</span> <span class="n">ret</span><span class="p">;</span>

  <span class="c1">// Perform phase 2 of object construction
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">switch</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
  <span class="p">{</span>
  <span class="k">case</span> <span class="n">mode</span><span class="o">::</span><span class="nl">attr_read</span><span class="p">:</span>
  <span class="k">case</span> <span class="n">mode</span><span class="o">::</span><span class="nl">read</span><span class="p">:</span>
    <span class="n">flags</span> <span class="o">=</span> <span class="n">O_RDONLY</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">mode</span><span class="o">::</span><span class="nl">attr_write</span><span class="p">:</span>
  <span class="k">case</span> <span class="n">mode</span><span class="o">::</span><span class="nl">write</span><span class="p">:</span>
    <span class="n">flags</span> <span class="o">=</span> <span class="n">O_RDWR</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">mode</span><span class="o">::</span><span class="nl">append</span><span class="p">:</span>
    <span class="n">flags</span> <span class="o">=</span> <span class="n">O_APPEND</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">default</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">errc</span><span class="o">::</span><span class="n">invalid_argument</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">ret</span><span class="p">.</span><span class="n">_fd</span> <span class="o">=</span> <span class="o">::</span><span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">u8string</span><span class="p">().</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">flags</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="n">ret</span><span class="p">.</span><span class="n">_fd</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Note that if we bail out here, ~file_handle() will correctly not call ::close()
</span><span class="c1"></span>    <span class="k">return</span> <span class="p">{</span><span class="n">errno</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">system_category</span><span class="p">()};</span>
  <span class="p">}</span>
  <span class="k">if</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="o">::</span><span class="n">fstat</span><span class="p">(</span><span class="n">ret</span><span class="p">.</span><span class="n">_fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ret</span><span class="p">.</span><span class="n">_stat</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="c1">// Note that if we bail out here, ~file_handle() will correctly call ::close()
</span><span class="c1"></span>    <span class="k">return</span> <span class="p">{</span><span class="n">errno</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">system_category</span><span class="p">()};</span>
  <span class="p">}</span>

  <span class="c1">// Returning ret directly is an area full of compiler specific behaviour quirks,
</span><span class="c1"></span>  <span class="c1">// so be explicit by wrapping into an initialiser list with embedded move.
</span><span class="c1"></span>  <span class="k">return</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">ret</span><span class="p">)};</span>
<span class="p">}</span>
</code></pre></div><a href="https://github.com/ned14/boost-outcome/tree/master/doc/src/snippets/constructors.cpp#L109" class="code-snippet-url" target="_blank">View this code on Github</a></div>


<p>The static member function implementing phase 2 firstly calls phase 1
which puts the object into a legally destructible state. We then
proceed to implement phase 2 of construction, filling in the various
parts as we go, reporting via <code>result</code> any failures.</p>

<div class="notices note" ><p>Remember that <code>operator new</code> has a non-throwing form, <code>new(std::nothrow)</code>.</p>
</div>


<p>For the final return, in theory we could just <code>return ret</code> and
depending on the C++ version currently in force, it might work
via move, or via copy, or it might refuse to compile. You can
of course type lots of boilerplate to be explicit, but this use
via initialiser list is a reasonable balance of explicitness
versus brevity, and it should generate minimum overhead code
irrespective of compiler, C++ version, or any other factor.</p>


        </div></body>
</html>
