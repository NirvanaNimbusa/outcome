<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Alternatives - Boost.Outcome documentation</title>
<link rel="stylesheet" href="/boost-outcome/css/boost.css" type="text/css">
<meta name="generator" content="Hugo with Boostdoc theme">
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>

<link rel="icon" href="/boost-outcome/images/favicon.ico" type="image/ico"/>
<body><div id="boost-common-heading-doc" style="background: #574D74 url(/boost-outcome/images/header-bg.png) repeat-x top left;">
  <div class="heading-inner" style="background: url(/boost-outcome/images/header-fg.png) no-repeat top left;">
  <div class="heading-placard"></div>

  <h1 class="heading-title">
    <a href="/">
      <img src="/boost-outcome/images/space.png" alt="Boost C++ Libraries" class="heading-logo" />
      <span class="heading-boost">Boost</span>
      <span class="heading-cpplibraries">C++ Libraries</span>
    </a>
  </h1>

  <p class="heading-quote">
    <q>...one of the most highly
    regarded and expertly designed C++ library projects in the
    world.</q> <span class="heading-attribution">&mdash; <a href=
    "http://www.gotw.ca/" class="external">Herb Sutter</a> and <a href=
    "http://en.wikipedia.org/wiki/Andrei_Alexandrescu" class="external">Andrei
    Alexandrescu</a>, <a href=
    "http://safari.awprofessional.com/?XmlId=0321113586" class="external">C++
    Coding Standards</a></span></p>
  </div>
</div>
<div id="boost-common-heading-doc-spacer"></div>
<div id="content">
    <p>No doubt many will dislike the two-stage invocation pattern i.e.</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">construct</span><span class="o">&lt;</span><span class="n">file_handle</span><span class="o">&gt;</span><span class="p">{</span><span class="s">&#34;hello&#34;</span><span class="p">}();</span>
</code></pre></div>
<p>So let us examine the most obvious alternative: a templated free function <code>construct&lt;T&gt;</code>.</p>

<p>Due to the inability to partially specialise templated functions in C++, you
need to use tagged overloading e.g.</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err">... </span><span class="nc">Args</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">outcome</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="n">file_handle</span><span class="o">&gt;</span> <span class="n">construct</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">in_place_type_t</span><span class="o">&lt;</span><span class="n">file_handle</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">file_handle</span><span class="o">::</span><span class="n">file</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="c1">// Now you must always write this:
</span><span class="c1"></span><span class="n">construct</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">in_place_type</span><span class="o">&lt;</span><span class="n">file_handle</span><span class="o">&gt;</span><span class="p">,</span> <span class="s">&#34;hello&#34;</span><span class="p">);</span>
</code></pre></div>
<p>Tagged overloading is fine for smaller projects, but for larger code bases:</p>

<ol>
<li>It takes longer to type <code>construct(std::in_place_type&lt;file_handle&gt;, &quot;hello&quot;)</code>,
and is possibly less intuitive to write,
than it does <code>construct&lt;file_handle&gt;{&quot;hello&quot;}()</code>.</li>
<li>Compiler error messages are enormously clearer if you encode the permitted
overloads for construction into the <code>construct&lt;file_handle&gt;</code> type rather than
letting a variadic free function fail to resolve an appropriate overload.</li>
<li>Resolving variadic free function overloads is not constant time for the compiler,
whereas resolving the type specialisation for <code>construct&lt;file_handle&gt;</code>
is constant time.</li>
<li>It actually turns out to be quite useful when writing generic code
to pass around object constructing factory objects all of which have
no parameters for their call operator. It becomes, effectively, a
<em>lazy construction</em> mechanism.</li>
</ol>


        </div></body>
</html>
