<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>TRY operations - Boost.Outcome documentation</title>
<link rel="stylesheet" href="/boost-outcome/css/boost.css" type="text/css">
<meta name="generator" content="Hugo with Boostdoc theme">
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>

<link rel="icon" href="/boost-outcome/images/favicon.ico" type="image/ico"/>
<body><div id="boost-common-heading-doc" style="background: #574D74 url(/boost-outcome/images/header-bg.png) repeat-x top left;">
  <div class="heading-inner" style="background: url(/boost-outcome/images/header-fg.png) no-repeat top left;">
  <div class="heading-placard"></div>

  <h1 class="heading-title">
    <a href="/">
      <img src="/boost-outcome/images/space.png" alt="Boost C++ Libraries" class="heading-logo" />
      <span class="heading-boost">Boost</span>
      <span class="heading-cpplibraries">C++ Libraries</span>
    </a>
  </h1>

  <p class="heading-quote">
    <q>...one of the most highly
    regarded and expertly designed C++ library projects in the
    world.</q> <span class="heading-attribution">&mdash; <a href=
    "http://www.gotw.ca/" class="external">Herb Sutter</a> and <a href=
    "http://en.wikipedia.org/wiki/Andrei_Alexandrescu" class="external">Andrei
    Alexandrescu</a>, <a href=
    "http://safari.awprofessional.com/?XmlId=0321113586" class="external">C++
    Coding Standards</a></span></p>
  </div>
</div>
<div id="boost-common-heading-doc-spacer"></div>
<div id="content">
    <p>In the implementation of function <code>print_half</code> we have seen the usage of the macro <a href="https://ned14.github.io/boost-outcome/reference/try" class="api-reference"><i class="fa fa-book" aria-hidden="true"></i> BOOST_OUTCOME_TRY</a>
:</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">BOOST_OUTCOME_TRY</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">BigInt</span><span class="o">::</span><span class="n">fromString</span><span class="p">(</span><span class="n">text</span><span class="p">));</span>
</code></pre></div>
<p>The <code>BOOST_OUTCOME_TRY</code> macro uses C macro overloading to select between two implementations based on the number of
input parameters. If there is exactly one input parameter i.e. without the <code>i,</code>, the control statement is
roughly equivalent to:</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">__result</span> <span class="o">=</span> <span class="n">BigInt</span><span class="o">::</span><span class="n">fromString</span><span class="p">(</span><span class="n">text</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__result</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">__result</span><span class="p">.</span><span class="n">as_failure</span><span class="p">();</span>
</code></pre></div>
<p>Where <code>__result</code> is a compile time generated unique name. If there are between two and eight parameters,
this control statement is roughly equivalent to:</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">__result</span> <span class="o">=</span> <span class="n">BigInt</span><span class="o">::</span><span class="n">fromString</span><span class="p">(</span><span class="n">text</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__result</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">__result</span><span class="p">.</span><span class="n">as_failure</span><span class="p">();</span>
<span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">__result</span><span class="p">.</span><span class="n">value</span><span class="p">();</span>
</code></pre></div>
<p>So here <code>i</code> as the first C macro parameter is set to the value of any successful result. To prevent
confounding of the C preprocessor, you should always wrap the function invocation in brackets. This is done
throughout this tutorial.</p>

<p>Additionally, in GCC and Clang which provide an extension to C++ known as
<a href="https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html" title="GCC docs on statement expressions">statement expressions</a>
it is possible to use an alternative macro: <code>BOOST_OUTCOME_TRYX</code>, which is an expression. With the above macro, the above declaration of variable <code>i</code> can be rewritten to:</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">BOOST_OUTCOME_TRYX</span> <span class="p">(</span><span class="n">BigInt</span><span class="o">::</span><span class="n">fromString</span><span class="p">(</span><span class="n">text</span><span class="p">));</span>
</code></pre></div>
<p>This has an advantage that you can use it any place where you can put an expression, e.g., in &ldquo;simple initialization&rdquo;:</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">if</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">BOOST_OUTCOME_TRYX</span><span class="p">(</span><span class="n">BigInt</span><span class="o">::</span><span class="n">fromString</span><span class="p">(</span><span class="n">text</span><span class="p">)))</span>
  <span class="n">use_a_non_zero_int</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</code></pre></div>
<p>or in as a subexpression of a bigger full expression:</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">BOOST_OUTCOME_TRYX</span><span class="p">(</span><span class="n">BigInt</span><span class="o">::</span><span class="n">fromString</span><span class="p">(</span><span class="s">&#34;1&#34;</span><span class="p">))</span> <span class="o">+</span> <span class="n">BOOST_OUTCOME_TRYX</span><span class="p">(</span><span class="n">BigInt</span><span class="o">::</span><span class="n">fromString</span><span class="p">(</span><span class="s">&#34;2&#34;</span><span class="p">));</span>
</code></pre></div>
<div class="notices note" ><p>This macro makes use of a proprietary extension in GCC and clang and is not
portable. The macro is not made available on unsupported compilers,
so you can test for its presence using <code>#ifdef BOOST_OUTCOME_TRYX</code>.</p>
</div>


<p>Macro <code>BOOST_OUTCOME_TRY</code> does two things:</p>

<ol>
<li>It extracts a <code>T</code> from <code>result&lt;T&gt;</code> (or <code>outcome&lt;T&gt;</code>).</li>
<li>It declares a dependency between statements: If the &ldquo;tried&rdquo; statement fails, the next statement is not executed.</li>
</ol>

<p>When you are calling functions that return <code>result&lt;void&gt;</code> the first of the two things does not make sense. You then have to use macro <code>BOOST_OUTCOME_TRYV</code> instead. Let&rsquo;s use our function <code>print_half</code>:</p>

<div class="code-snippet"><div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++">
<span class="n">outcome</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">test</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">BOOST_OUTCOME_TRY</span> <span class="p">((</span><span class="n">print_half</span><span class="p">(</span><span class="s">&#34;2&#34;</span><span class="p">)));</span>
  <span class="n">BOOST_OUTCOME_TRY</span> <span class="p">((</span><span class="n">print_half</span><span class="p">(</span><span class="s">&#34;X&#34;</span><span class="p">)));</span>
  <span class="n">BOOST_OUTCOME_TRY</span> <span class="p">((</span><span class="n">print_half</span><span class="p">(</span><span class="s">&#34;4&#34;</span><span class="p">)));</span> <span class="c1">// will not execute
</span><span class="c1"></span>  <span class="k">return</span> <span class="n">outcome</span><span class="o">::</span><span class="n">success</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div><a href="https://github.com/ned14/boost-outcome/tree/master/doc/src/snippets/using_result.cpp#L141" class="code-snippet-url" target="_blank">View this code on Github</a></div>


<p>The first statement will succeed. The second statement will &ldquo;fail&rdquo;, i.e. it will return an <em>errored</em> result. This will cause an immediate return and the subsequent statements will be skipped.</p>


        </div></body>
</html>
