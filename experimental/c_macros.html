<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>C macro API - Boost.Outcome documentation</title>
<link rel="stylesheet" href="../css/boost.css" type="text/css">
<meta name="generator" content="Hugo 0.52 with Boostdoc theme">
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>

<link rel="icon" href="../images/favicon.ico" type="image/ico"/>
<body><div id="boost-common-heading-doc" style="background: #574D74 url('../images/header-bg.png') repeat-x top left;">
  <div class="heading-inner" style="background: url('../images/header-fg.png') no-repeat top left;">
  <div class="heading-placard"></div>

  <h1 class="heading-title">
    <a href="../">
      <img src="../images/space.png" alt="Boost C++ Libraries" class="heading-logo" />
      <span class="heading-boost">Boost</span>
      <span class="heading-cpplibraries">C++ Libraries</span>
    </a>
  </h1>

  <p class="heading-quote">
    <q>...one of the most highly
    regarded and expertly designed C++ library projects in the
    world.</q> <span class="heading-attribution">&mdash; <a href=
    "http://www.gotw.ca/" class="external">Herb Sutter</a> and <a href=
    "http://en.wikipedia.org/wiki/Andrei_Alexandrescu" class="external">Andrei
    Alexandrescu</a>, <a href=
    "http://safari.awprofessional.com/?XmlId=0321113586" class="external">C++
    Coding Standards</a></span></p>
  </div>
</div>
<div id="boost-common-heading-doc-spacer"></div><div class="spirit-nav">
<a accesskey="p" href="../experimental/erased_status_result.html"><img src="../images/prev.png" alt="Prev"></a>
    <a accesskey="u" href="../experimental.html"><img src="../images/up.png" alt="Up"></a>
    <a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="../experimental/worked-example.html"><img src="../images/next.png" alt="Next"></a></div><div id="content">
  <div class="titlepage"><div><div><h1 style="clear: both">C macro API</h1></div></div></div>
  

<p>The C macro API permits C code to call C++ functions which return the subset
of possible <a href="../reference/types/basic_result.html" class="api-reference">basic_result&lt;T, E, NoValuePolicy&gt;</a> which are C-compatible,
so specifically:</p>

<ol>
<li><code>T</code> and <code>E</code> must be trivially copyable or move relocating<sup class="footnote-ref" id="fnref:1"><a href="#fn:1">1</a></sup>.</li>
<li><code>T</code> and <code>E</code> must have standard layout<sup class="footnote-ref" id="fnref:2"><a href="#fn:2">2</a></sup>.</li>
</ol>

<p>P1028 status code guarantees that it is both of the above if its domain&rsquo;s
<code>value_type</code> meets the above, which is the case for all of the status code
domains bundled with <a href="https://ned14.github.io/status-code/">https://ned14.github.io/status-code/</a>. Thus, if
you return from C++ a result which is wholly configured with C-compatible
types, C functions may return that result type.</p>

<p>The C macro API header <code>&lt;boost/outcome/experimental/result.h&gt;</code> consists of these macros:</p>

<dl>
<dt><code>BOOST_OUTCOME_C_DECLARE_STATUS_CODE(ident, value_type)</code>
<dd>Declares to C a status code type with domain <code>value_type</code>
available at the member variable <code>.value</code>. The <code>ident</code>
must be any identifier fragment unique in this translation unit. It is
used to uniquely identify this status code type in other macros.

<dt><code>BOOST_OUTCOME_C_STATUS_CODE(ident)</code>
<dd>A reference to a previously declared status code type with unique
<code>ident</code>.

<dt><code>BOOST_OUTCOME_C_DECLARE_RESULT(ident, T, E)</code>
<dd>Declares to C a <code>basic_result<T, E></code> type uniquely
identified by <code>ident</code>. <code>T</code> is available at the
member variable <code>.value</code>, and <code>E</code> is available
at the member variable <code>.error</code>.

<dt><code>BOOST_OUTCOME_C_RESULT(ident)</code>
<dd>A reference to a previously declared <code>result</code> type with
unique <code>ident</code>.

<dt><code>BOOST_OUTCOME_C_RESULT_HAS_VALUE(r)</code>
<dd>Evaluates to 1 (true) if the input <code>result</code> has a value.

<dt><code>BOOST_OUTCOME_C_RESULT_HAS_ERROR(r)</code>
<dd>Evaluates to 1 (true) if the input <code>result</code> has an error.

<dt><code>BOOST_OUTCOME_C_RESULT_ERROR_IS_ERRNO(r)</code>
<dd>Evaluates to 1 (true) if the input <code>result</code>'s error value
is a code in the POSIX <code>errno</code> domain.
</dl>

<p>The above let you work, somewhat awkwardly, with any C-compatible
<code>basic_result&lt;T, E&gt;</code>. There is a high likelihood that C++ functions
regularly called by C code will return their failures in the <code>errno</code>
code domain, which is understood natively by C and can be compared
against, fed to <code>strerror()</code> and so on. Therefore there are
convenience macro APIs for that particular use case.</p>

<p><dl>
<dt><code>BOOST_OUTCOME_C_DECLARE_RESULT_ERRNO(ident, T)</code>
<dd>Declares to C a <code>basic_result<T, posix_code></code>
type uniquely identified by <code>ident</code>.</p>

<p><dt><code>BOOST_OUTCOME_C_RESULT_ERRNO(ident)</code>
<dd>A reference to a previously declared <code>basic_result<T, posix_code>&gt;</code>
type with unique <code>ident</code>.
</dl>
<br></p>

<h3 id="example-of-use">Example of use</h3>

<p>We first declare the <code>result</code> type returned by the C++ function <code>to_string()</code>,
and then the C++ function itself as an extern function (note the Itanium ABI
mangling).</p>

<div class="code-snippet"><div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;  // for strerror</span><span class="cp">
</span><span class="cp"></span><span class="c1">// This header in Experimental Outcome is pure C, it provides a suite of C helper macros
</span><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&#34;../../../include/outcome/experimental/result.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">// Declare our C++ function&#39;s returning result type. Only needs to be done once.
</span><span class="c1">// This declares a `basic_result&lt;size_t, posix_code&gt;`.
</span><span class="c1">//
</span><span class="c1">// The first parameter is some unique identifier for this type which will be used
</span><span class="c1">// whenever we reference this type in the future.
</span><span class="c1"></span><span class="n">CXX_DECLARE_RESULT_ERRNO</span><span class="p">(</span><span class="n">to_string_rettype</span><span class="p">,</span> <span class="n">size_t</span><span class="p">);</span>

<span class="c1">// Tell C about our extern C++ function `to_string()`
</span><span class="c1"></span><span class="k">extern</span> <span class="nf">CXX_RESULT_ERRNO</span><span class="p">(</span><span class="n">to_string_rettype</span><span class="p">)</span> <span class="n">_Z9to_stringPcmi</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">bufferlen</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">);</span>
</code></pre></div><a href="https://github.com/boostorg/outcome/tree/master/doc/src/snippets/c_api.c#L33" class="code-snippet-url" target="_blank">View this code on Github</a></div>


<p>As an example of using the C macro API:</p>

<div class="code-snippet"><div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
  <span class="n">CXX_RESULT_ERRNO</span><span class="p">(</span><span class="n">to_string_rettype</span><span class="p">)</span> <span class="n">res</span><span class="p">;</span>

  <span class="n">res</span> <span class="o">=</span> <span class="n">_Z9to_stringPcmi</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span> <span class="n">v</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">CXX_RESULT_HAS_VALUE</span><span class="p">(</span><span class="n">res</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;to_string(%d) fills buffer with &#39;%s&#39; of %zu characters</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">res</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// Is the error returned in the POSIX domain and thus an errno?
</span><span class="c1"></span>  <span class="k">if</span><span class="p">(</span><span class="n">CXX_RESULT_ERROR_IS_ERRNO</span><span class="p">(</span><span class="n">res</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;to_string(%d) failed with error code %d (%s)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">res</span><span class="p">.</span><span class="n">error</span><span class="p">.</span><span class="n">value</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">error</span><span class="p">.</span><span class="n">value</span><span class="p">));</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;to_string(%d) failed with unknown error code %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">res</span><span class="p">.</span><span class="n">error</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><a href="https://github.com/boostorg/outcome/tree/master/doc/src/snippets/c_api.c#L50" class="code-snippet-url" target="_blank">View this code on Github</a></div>


<p>And finally, if we run this test program:</p>

<div class="code-snippet"><div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="mi">9</span><span class="p">);</span>
  <span class="n">print</span><span class="p">(</span><span class="mi">99</span><span class="p">);</span>
  <span class="n">print</span><span class="p">(</span><span class="mi">999</span><span class="p">);</span>
  <span class="n">print</span><span class="p">(</span><span class="mi">9999</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><a href="https://github.com/boostorg/outcome/tree/master/doc/src/snippets/c_api.c#L72" class="code-snippet-url" target="_blank">View this code on Github</a></div>


<p>The program outputs:</p>

<pre><code>to_string(9) fills buffer with '9' of 1 characters
to_string(99) fills buffer with '99' of 2 characters
to_string(999) fills buffer with '999' of 3 characters
to_string(9999) failed with error code 105 (No buffer space available)
</code></pre>
<div class="footnotes">

<hr />

<ol>
<li id="fn:1">As mentioned earlier, move relocating types are not in the standard. As currently proposed for standardisation, they would have the ability to <em>pass through</em> C code whereby it would be standards defined behaviour for a move relocating type to begin and end lifetime within C++, but spend some of its lifetime within C. In other words, C can safely bit-copy move relocating types, so long as the final destination returns to C++ so it can be destructed appropriately.
 <a class="footnote-return" href="#fnref:1"><sup>[return]</sup></a></li>
<li id="fn:2">Many C and C++ compilers waive the standard layout requirement for C and C++ interop, but standards conforming code should meet it.
 <a class="footnote-return" href="#fnref:2"><sup>[return]</sup></a></li>
</ol>
</div>


        </div><p><small>Last revised: January 28, 2019 at 22:40:33 UTC</small></p>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../experimental/erased_status_result.html"><img src="../images/prev.png" alt="Prev"></a>
    <a accesskey="u" href="../experimental.html"><img src="../images/up.png" alt="Up"></a>
    <a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="../experimental/worked-example.html"><img src="../images/next.png" alt="Next"></a></div></body>
</html>
